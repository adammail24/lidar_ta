// Generated by gencpp from file ros_er/commands_srvResponse.msg
// DO NOT EDIT!


#ifndef ROS_ER_MESSAGE_COMMANDS_SRVRESPONSE_H
#define ROS_ER_MESSAGE_COMMANDS_SRVRESPONSE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ros_er
{
template <class ContainerAllocator>
struct commands_srvResponse_
{
  typedef commands_srvResponse_<ContainerAllocator> Type;

  commands_srvResponse_()
    : arg0(0)
    , arg1(0)
    , arg2(0)
    , arg3(0)
    , arg4(0)
    , arg5(0)
    , arg6(0)
    , arg7(0)
    , arg8(0)
    , arg9(0)
    , arg10(0)
    , arg11(0)
    , arg12(0)
    , arg13(0)
    , arg14(0)
    , arg15(0)
    , arg16(0)
    , arg17(0)
    , arg18(0)
    , arg19(0)
    , arg20(0)
    , arg21(0)
    , arg22(0)
    , arg23(0)
    , arg24(0)
    , arg25(0)  {
    }
  commands_srvResponse_(const ContainerAllocator& _alloc)
    : arg0(0)
    , arg1(0)
    , arg2(0)
    , arg3(0)
    , arg4(0)
    , arg5(0)
    , arg6(0)
    , arg7(0)
    , arg8(0)
    , arg9(0)
    , arg10(0)
    , arg11(0)
    , arg12(0)
    , arg13(0)
    , arg14(0)
    , arg15(0)
    , arg16(0)
    , arg17(0)
    , arg18(0)
    , arg19(0)
    , arg20(0)
    , arg21(0)
    , arg22(0)
    , arg23(0)
    , arg24(0)
    , arg25(0)  {
  (void)_alloc;
    }



   typedef int32_t _arg0_type;
  _arg0_type arg0;

   typedef int32_t _arg1_type;
  _arg1_type arg1;

   typedef int32_t _arg2_type;
  _arg2_type arg2;

   typedef int32_t _arg3_type;
  _arg3_type arg3;

   typedef int32_t _arg4_type;
  _arg4_type arg4;

   typedef int32_t _arg5_type;
  _arg5_type arg5;

   typedef int32_t _arg6_type;
  _arg6_type arg6;

   typedef int32_t _arg7_type;
  _arg7_type arg7;

   typedef int32_t _arg8_type;
  _arg8_type arg8;

   typedef int32_t _arg9_type;
  _arg9_type arg9;

   typedef int32_t _arg10_type;
  _arg10_type arg10;

   typedef int32_t _arg11_type;
  _arg11_type arg11;

   typedef int32_t _arg12_type;
  _arg12_type arg12;

   typedef int32_t _arg13_type;
  _arg13_type arg13;

   typedef int32_t _arg14_type;
  _arg14_type arg14;

   typedef int32_t _arg15_type;
  _arg15_type arg15;

   typedef int32_t _arg16_type;
  _arg16_type arg16;

   typedef int32_t _arg17_type;
  _arg17_type arg17;

   typedef int32_t _arg18_type;
  _arg18_type arg18;

   typedef int32_t _arg19_type;
  _arg19_type arg19;

   typedef int32_t _arg20_type;
  _arg20_type arg20;

   typedef int32_t _arg21_type;
  _arg21_type arg21;

   typedef int32_t _arg22_type;
  _arg22_type arg22;

   typedef int32_t _arg23_type;
  _arg23_type arg23;

   typedef int32_t _arg24_type;
  _arg24_type arg24;

   typedef int32_t _arg25_type;
  _arg25_type arg25;





  typedef boost::shared_ptr< ::ros_er::commands_srvResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_er::commands_srvResponse_<ContainerAllocator> const> ConstPtr;

}; // struct commands_srvResponse_

typedef ::ros_er::commands_srvResponse_<std::allocator<void> > commands_srvResponse;

typedef boost::shared_ptr< ::ros_er::commands_srvResponse > commands_srvResponsePtr;
typedef boost::shared_ptr< ::ros_er::commands_srvResponse const> commands_srvResponseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_er::commands_srvResponse_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_er::commands_srvResponse_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ros_er::commands_srvResponse_<ContainerAllocator1> & lhs, const ::ros_er::commands_srvResponse_<ContainerAllocator2> & rhs)
{
  return lhs.arg0 == rhs.arg0 &&
    lhs.arg1 == rhs.arg1 &&
    lhs.arg2 == rhs.arg2 &&
    lhs.arg3 == rhs.arg3 &&
    lhs.arg4 == rhs.arg4 &&
    lhs.arg5 == rhs.arg5 &&
    lhs.arg6 == rhs.arg6 &&
    lhs.arg7 == rhs.arg7 &&
    lhs.arg8 == rhs.arg8 &&
    lhs.arg9 == rhs.arg9 &&
    lhs.arg10 == rhs.arg10 &&
    lhs.arg11 == rhs.arg11 &&
    lhs.arg12 == rhs.arg12 &&
    lhs.arg13 == rhs.arg13 &&
    lhs.arg14 == rhs.arg14 &&
    lhs.arg15 == rhs.arg15 &&
    lhs.arg16 == rhs.arg16 &&
    lhs.arg17 == rhs.arg17 &&
    lhs.arg18 == rhs.arg18 &&
    lhs.arg19 == rhs.arg19 &&
    lhs.arg20 == rhs.arg20 &&
    lhs.arg21 == rhs.arg21 &&
    lhs.arg22 == rhs.arg22 &&
    lhs.arg23 == rhs.arg23 &&
    lhs.arg24 == rhs.arg24 &&
    lhs.arg25 == rhs.arg25;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ros_er::commands_srvResponse_<ContainerAllocator1> & lhs, const ::ros_er::commands_srvResponse_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ros_er

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ros_er::commands_srvResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_er::commands_srvResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_er::commands_srvResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_er::commands_srvResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_er::commands_srvResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_er::commands_srvResponse_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_er::commands_srvResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7a06f282c5865fe19b3c0085420e8073";
  }

  static const char* value(const ::ros_er::commands_srvResponse_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7a06f282c5865fe1ULL;
  static const uint64_t static_value2 = 0x9b3c0085420e8073ULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_er::commands_srvResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_er/commands_srvResponse";
  }

  static const char* value(const ::ros_er::commands_srvResponse_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_er::commands_srvResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 arg0\n"
"int32 arg1\n"
"int32 arg2\n"
"int32 arg3\n"
"int32 arg4\n"
"int32 arg5\n"
"int32 arg6\n"
"int32 arg7\n"
"int32 arg8\n"
"int32 arg9\n"
"int32 arg10\n"
"int32 arg11\n"
"int32 arg12\n"
"int32 arg13\n"
"int32 arg14\n"
"int32 arg15\n"
"int32 arg16\n"
"int32 arg17\n"
"int32 arg18\n"
"int32 arg19\n"
"int32 arg20\n"
"int32 arg21\n"
"int32 arg22\n"
"int32 arg23\n"
"int32 arg24\n"
"int32 arg25\n"
"#int32[] args\n"
;
  }

  static const char* value(const ::ros_er::commands_srvResponse_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_er::commands_srvResponse_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.arg0);
      stream.next(m.arg1);
      stream.next(m.arg2);
      stream.next(m.arg3);
      stream.next(m.arg4);
      stream.next(m.arg5);
      stream.next(m.arg6);
      stream.next(m.arg7);
      stream.next(m.arg8);
      stream.next(m.arg9);
      stream.next(m.arg10);
      stream.next(m.arg11);
      stream.next(m.arg12);
      stream.next(m.arg13);
      stream.next(m.arg14);
      stream.next(m.arg15);
      stream.next(m.arg16);
      stream.next(m.arg17);
      stream.next(m.arg18);
      stream.next(m.arg19);
      stream.next(m.arg20);
      stream.next(m.arg21);
      stream.next(m.arg22);
      stream.next(m.arg23);
      stream.next(m.arg24);
      stream.next(m.arg25);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct commands_srvResponse_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_er::commands_srvResponse_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_er::commands_srvResponse_<ContainerAllocator>& v)
  {
    s << indent << "arg0: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg0);
    s << indent << "arg1: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg1);
    s << indent << "arg2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg2);
    s << indent << "arg3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg3);
    s << indent << "arg4: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg4);
    s << indent << "arg5: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg5);
    s << indent << "arg6: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg6);
    s << indent << "arg7: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg7);
    s << indent << "arg8: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg8);
    s << indent << "arg9: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg9);
    s << indent << "arg10: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg10);
    s << indent << "arg11: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg11);
    s << indent << "arg12: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg12);
    s << indent << "arg13: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg13);
    s << indent << "arg14: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg14);
    s << indent << "arg15: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg15);
    s << indent << "arg16: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg16);
    s << indent << "arg17: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg17);
    s << indent << "arg18: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg18);
    s << indent << "arg19: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg19);
    s << indent << "arg20: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg20);
    s << indent << "arg21: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg21);
    s << indent << "arg22: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg22);
    s << indent << "arg23: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg23);
    s << indent << "arg24: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg24);
    s << indent << "arg25: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg25);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_ER_MESSAGE_COMMANDS_SRVRESPONSE_H
