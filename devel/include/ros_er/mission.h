// Generated by gencpp from file ros_er/mission.msg
// DO NOT EDIT!


#ifndef ROS_ER_MESSAGE_MISSION_H
#define ROS_ER_MESSAGE_MISSION_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ros_er
{
template <class ContainerAllocator>
struct mission_
{
  typedef mission_<ContainerAllocator> Type;

  mission_()
    : command(0)
    , arg1(0)
    , arg2(0)
    , arg3(0)
    , arg4(0)
    , arg5(0)
    , arg6(0)
    , arg7(0)
    , arg8(0)
    , arg9(0)
    , arg10(0)
    , arg11(0)
    , arg12(0)
    , arg13(0)
    , arg14(0)
    , arg15(0)
    , arg16(0)
    , arg17(0)
    , arg18(0)
    , arg19(0)
    , arg20(0)
    , behaviour(0)
    , timeafter(0)
    , mission_counter(0)  {
    }
  mission_(const ContainerAllocator& _alloc)
    : command(0)
    , arg1(0)
    , arg2(0)
    , arg3(0)
    , arg4(0)
    , arg5(0)
    , arg6(0)
    , arg7(0)
    , arg8(0)
    , arg9(0)
    , arg10(0)
    , arg11(0)
    , arg12(0)
    , arg13(0)
    , arg14(0)
    , arg15(0)
    , arg16(0)
    , arg17(0)
    , arg18(0)
    , arg19(0)
    , arg20(0)
    , behaviour(0)
    , timeafter(0)
    , mission_counter(0)  {
  (void)_alloc;
    }



   typedef uint16_t _command_type;
  _command_type command;

   typedef int32_t _arg1_type;
  _arg1_type arg1;

   typedef int32_t _arg2_type;
  _arg2_type arg2;

   typedef int32_t _arg3_type;
  _arg3_type arg3;

   typedef int32_t _arg4_type;
  _arg4_type arg4;

   typedef int32_t _arg5_type;
  _arg5_type arg5;

   typedef int32_t _arg6_type;
  _arg6_type arg6;

   typedef int32_t _arg7_type;
  _arg7_type arg7;

   typedef int32_t _arg8_type;
  _arg8_type arg8;

   typedef int32_t _arg9_type;
  _arg9_type arg9;

   typedef int32_t _arg10_type;
  _arg10_type arg10;

   typedef int32_t _arg11_type;
  _arg11_type arg11;

   typedef int32_t _arg12_type;
  _arg12_type arg12;

   typedef int32_t _arg13_type;
  _arg13_type arg13;

   typedef int32_t _arg14_type;
  _arg14_type arg14;

   typedef int32_t _arg15_type;
  _arg15_type arg15;

   typedef int32_t _arg16_type;
  _arg16_type arg16;

   typedef int32_t _arg17_type;
  _arg17_type arg17;

   typedef int32_t _arg18_type;
  _arg18_type arg18;

   typedef int32_t _arg19_type;
  _arg19_type arg19;

   typedef int32_t _arg20_type;
  _arg20_type arg20;

   typedef int16_t _behaviour_type;
  _behaviour_type behaviour;

   typedef int32_t _timeafter_type;
  _timeafter_type timeafter;

   typedef uint16_t _mission_counter_type;
  _mission_counter_type mission_counter;





  typedef boost::shared_ptr< ::ros_er::mission_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_er::mission_<ContainerAllocator> const> ConstPtr;

}; // struct mission_

typedef ::ros_er::mission_<std::allocator<void> > mission;

typedef boost::shared_ptr< ::ros_er::mission > missionPtr;
typedef boost::shared_ptr< ::ros_er::mission const> missionConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_er::mission_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_er::mission_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ros_er::mission_<ContainerAllocator1> & lhs, const ::ros_er::mission_<ContainerAllocator2> & rhs)
{
  return lhs.command == rhs.command &&
    lhs.arg1 == rhs.arg1 &&
    lhs.arg2 == rhs.arg2 &&
    lhs.arg3 == rhs.arg3 &&
    lhs.arg4 == rhs.arg4 &&
    lhs.arg5 == rhs.arg5 &&
    lhs.arg6 == rhs.arg6 &&
    lhs.arg7 == rhs.arg7 &&
    lhs.arg8 == rhs.arg8 &&
    lhs.arg9 == rhs.arg9 &&
    lhs.arg10 == rhs.arg10 &&
    lhs.arg11 == rhs.arg11 &&
    lhs.arg12 == rhs.arg12 &&
    lhs.arg13 == rhs.arg13 &&
    lhs.arg14 == rhs.arg14 &&
    lhs.arg15 == rhs.arg15 &&
    lhs.arg16 == rhs.arg16 &&
    lhs.arg17 == rhs.arg17 &&
    lhs.arg18 == rhs.arg18 &&
    lhs.arg19 == rhs.arg19 &&
    lhs.arg20 == rhs.arg20 &&
    lhs.behaviour == rhs.behaviour &&
    lhs.timeafter == rhs.timeafter &&
    lhs.mission_counter == rhs.mission_counter;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ros_er::mission_<ContainerAllocator1> & lhs, const ::ros_er::mission_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ros_er

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ros_er::mission_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_er::mission_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_er::mission_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_er::mission_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_er::mission_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_er::mission_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_er::mission_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8b255d36a9b5156d79792657084a67cf";
  }

  static const char* value(const ::ros_er::mission_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8b255d36a9b5156dULL;
  static const uint64_t static_value2 = 0x79792657084a67cfULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_er::mission_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_er/mission";
  }

  static const char* value(const ::ros_er::mission_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_er::mission_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint16 command\n"
"int32 arg1\n"
"int32 arg2\n"
"int32 arg3\n"
"int32 arg4\n"
"int32 arg5\n"
"int32 arg6\n"
"int32 arg7\n"
"int32 arg8\n"
"int32 arg9\n"
"int32 arg10\n"
"int32 arg11\n"
"int32 arg12\n"
"int32 arg13\n"
"int32 arg14\n"
"int32 arg15\n"
"int32 arg16\n"
"int32 arg17\n"
"int32 arg18\n"
"int32 arg19\n"
"int32 arg20\n"
"int16 behaviour\n"
"int32 timeafter\n"
"uint16 mission_counter\n"
;
  }

  static const char* value(const ::ros_er::mission_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_er::mission_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.command);
      stream.next(m.arg1);
      stream.next(m.arg2);
      stream.next(m.arg3);
      stream.next(m.arg4);
      stream.next(m.arg5);
      stream.next(m.arg6);
      stream.next(m.arg7);
      stream.next(m.arg8);
      stream.next(m.arg9);
      stream.next(m.arg10);
      stream.next(m.arg11);
      stream.next(m.arg12);
      stream.next(m.arg13);
      stream.next(m.arg14);
      stream.next(m.arg15);
      stream.next(m.arg16);
      stream.next(m.arg17);
      stream.next(m.arg18);
      stream.next(m.arg19);
      stream.next(m.arg20);
      stream.next(m.behaviour);
      stream.next(m.timeafter);
      stream.next(m.mission_counter);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mission_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_er::mission_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_er::mission_<ContainerAllocator>& v)
  {
    s << indent << "command: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.command);
    s << indent << "arg1: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg1);
    s << indent << "arg2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg2);
    s << indent << "arg3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg3);
    s << indent << "arg4: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg4);
    s << indent << "arg5: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg5);
    s << indent << "arg6: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg6);
    s << indent << "arg7: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg7);
    s << indent << "arg8: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg8);
    s << indent << "arg9: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg9);
    s << indent << "arg10: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg10);
    s << indent << "arg11: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg11);
    s << indent << "arg12: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg12);
    s << indent << "arg13: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg13);
    s << indent << "arg14: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg14);
    s << indent << "arg15: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg15);
    s << indent << "arg16: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg16);
    s << indent << "arg17: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg17);
    s << indent << "arg18: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg18);
    s << indent << "arg19: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg19);
    s << indent << "arg20: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arg20);
    s << indent << "behaviour: ";
    Printer<int16_t>::stream(s, indent + "  ", v.behaviour);
    s << indent << "timeafter: ";
    Printer<int32_t>::stream(s, indent + "  ", v.timeafter);
    s << indent << "mission_counter: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.mission_counter);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_ER_MESSAGE_MISSION_H
